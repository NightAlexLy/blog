---
title: 技术问题总结
tag:
   - stackoverflow
   - java
   - android
   - 测试
---

#### <a name="test1">Java += 操作符实质</a> ####

**问题 我之前以为： i += j 等同于 i = i + j; 但假设有：**  

    int i = 5;
    long j = 8;
 
  这时 i = i + j 不能编译，但 i += j 却可以编译。这说明两者还是有差别的 这是否意味着，i += j，实际是等同于 i= (type of i) (i + j)呢？

**回答 这个问题，其实官方文档中已经解答了。 请看这里**[ §15.26.2 Compound Assignment Operators](http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.26.2) 

再照搬下官方文档的说明

对复合赋值表达式来说，E1 op= E2 (诸如 i += j; i -= j 等等)，其实是等同于 E1 = (T)((E1) op (E2))，其中，T是E1这个元素的类型。

举例来说，如下的代码

    short x = 3;
    x += 4.6;
等同于

    short x = 3;
    x = (short)(x + 4.6);

#### <a name="test2">将InputStream转换为String</a> ####


使用Apache库 不重复造轮子。最靠谱的方法，还是用Apache commons IOUtils 这样简单几行代码就搞定了

    StringWriter writer = new StringWriter();
    IOUtils.copy(inputStream, writer, encoding);
    String theString = writer.toString();
    或者 String theString = IOUtils.toString(inputStream, encoding)//这个方法其实封装了上面的方法，减少了一个参数

**使用原生库 如果不想引入Apache库，也可以这样做**

    static String convertStreamToString(java.io.InputStream is) {
      java.util.Scanner s = new java.util.Scanner(is).useDelimiter("\\A"); 
      return s.hasNext() ? s.next() : "";
    }

#### <a name="test3">将数组转换为List</a> ####

**问题 假设有数组**

    Element[] array = {new Element(1),new Element(2),new Element(3)};
如何将其转换为ArrayList<Element> arraylist = ？？？

**回答1**


    new ArrayList<Element>(Arrays.asList(array))
**回答2**

    Arrays.asList(array)或者Arrays.asList(new Element(1),new Element(2),new Element(3))

不过，这样做有些坑要注意：

1.这样做生成的list，是定长的。也就是说，如果你对它做add或者remove，都会抛UnsupportedOperationException。  
2.如果修改数组的值，list中的对应值也会改变！  
**Arrays.asList() 返回的是Arrays内部静态类，而不是Java.util.ArrayList的类。这个java.util.Arrays.ArrayList有set(),get(),contains()方法，但是没有任何add() 方法，所以它是固定大小的**

如果希望避免这两个坑，请改用这个方式

    Collections.addAll(arraylist, array);


#### <a name="test4">HashMap遍历</a> ####

在Java中有多种遍历HashMAp的方法。让我们回顾一下最常见的方法和它们各自的优缺点。由于所有的Map都实现了Map接口，所以接下来方法适用于所有Map（如：HaspMap，TreeMap,LinkedMap,HashTable,etc）

方法#1 使用For-Each迭代entries

这是最常见的方法，并在大多数情况下更可取的。当你在循环中需要使用Map的键和值时，就可以使用这个方法

    Map<Integer, Integer> map = new HashMap<Integer, Integer>();
    for(Map.Entry<Integer, Integer> entry : map.entrySet()){
    	System.out.println("key = " + entry.getKey() + ", value = " + entry.getValue())
    }
注意：For-Each循环是Java5新引入的，所以只能在Java5以上的版本中使用。如果你遍历的map是null的话，For-Each循环会抛出NullPointerException异常，所以在遍历之前你应该判断是否为空引用。

方法#2 使用For-Each迭代keys和values

如果你只需要用到map的keys或values时，你可以遍历KeySet或者values代替entrySet

    Map<Integer, Integer> map = new HashMap<Integer, Integer>();
    
    //iterating over keys only
    for (Integer key : map.keySet()) {
    	System.out.println("Key = " + key);
    }
    
    //iterating over values only
    for (Integer value : map.values()) {
    	System.out.println("Value = " + value);
    }
这个方法比entrySet迭代具有轻微的性能优势(大约快10%)并且代码更简洁

方法#3 使用Iterator迭代

    使用泛型
    
    Map<Integer, Integer> map = new HashMap<Integer, Integer>();
    Iterator<Map.Entry<Integer, Integer>> entries = map.entrySet().iterator();
    while (entries.hasNext()) {
    	Map.Entry<Integer, Integer> entry = entries.next();
    	System.out.println("Key = " + entry.getKey() + ", Value = " + entry.getValue());
    }
    不使用泛型
    
    Map map = new HashMap();
    Iterator entries = map.entrySet().iterator();
    while (entries.hasNext()) {
    	Map.Entry entry = (Map.Entry) entries.next();
    	Integer key = (Integer)entry.getKey();
    	Integer value = (Integer)entry.getValue();
    	System.out.println("Key = " + key + ", Value = " + value);
    }
你可以使用同样的技术迭代keyset或者values

这个似乎有点多余但它具有自己的优势。首先，它是遍历老java版本map的唯一方法。另外一个重要的特性是可以让你在迭代的时候从map中删除entries的(通过调用iterator.remover())唯一方法.如果你试图在For-Each迭代的时候删除entries，你将会得到unpredictable resultes 异常。

从性能方法看，这个方法等价于使用For-Each迭代

方法#4 迭代keys并搜索values（低效的）

    Map<Integer, Integer> map = new HashMap<Integer, Integer>();
    for (Integer key : map.keySet()) {
    	Integer value = map.get(key);
    	System.out.println("Key = " + key + ", Value = " + value);
    }
这个方法看上去比方法#1更简洁，但是实际上它更慢更低效，通过key得到value值更耗时（这个方法在所有实现map接口的map中比方法#1慢20%-200%）。如果你安装了FindBugs，它将检测并警告你这是一个低效的迭代。这个方法应该避免

总结

如果你只需要使用key或者value使用方法#2，如果你坚持使用java的老版本（java 5 以前的版本）或者打算在迭代的时候移除entries，使用方法#3。其他情况请使用#1方法。避免使用#4方法。
