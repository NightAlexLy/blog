---
title: 技术问题总结
tag:
   - stackoverflow
   - java
   - android
   - 测试
---

#### <a name="test1">Java += 操作符实质</a> ####

**问题 我之前以为： i += j 等同于 i = i + j; 但假设有：**  

    int i = 5;
    long j = 8;

  这时 i = i + j 不能编译，但 i += j 却可以编译。这说明两者还是有差别的 这是否意味着，i += j，实际是等同于 i= (type of i) (i + j)呢？

**回答 这个问题，其实官方文档中已经解答了。 请看这里**[ §15.26.2 Compound Assignment Operators](http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.26.2)

再照搬下官方文档的说明

对复合赋值表达式来说，E1 op= E2 (诸如 i += j; i -= j 等等)，其实是等同于 E1 = (T)((E1) op (E2))，其中，T是E1这个元素的类型。

举例来说，如下的代码

    short x = 3;
    x += 4.6;
等同于

    short x = 3;
    x = (short)(x + 4.6);

#### <a name="test2">将InputStream转换为String</a> ####


使用Apache库 不重复造轮子。最靠谱的方法，还是用Apache commons IOUtils 这样简单几行代码就搞定了

    StringWriter writer = new StringWriter();
    IOUtils.copy(inputStream, writer, encoding);
    String theString = writer.toString();
    或者 String theString = IOUtils.toString(inputStream, encoding)//这个方法其实封装了上面的方法，减少了一个参数

**使用原生库 如果不想引入Apache库，也可以这样做**

    static String convertStreamToString(java.io.InputStream is) {
      java.util.Scanner s = new java.util.Scanner(is).useDelimiter("\\A");
      return s.hasNext() ? s.next() : "";
    }

#### <a name="test3">将数组转换为List</a> ####

**问题 假设有数组**

    Element[] array = {new Element(1),new Element(2),new Element(3)};
如何将其转换为ArrayList<Element> arraylist = ？？？

**回答1**


    new ArrayList<Element>(Arrays.asList(array))
**回答2**

    Arrays.asList(array)或者Arrays.asList(new Element(1),new Element(2),new Element(3))

不过，这样做有些坑要注意：

1.这样做生成的list，是定长的。也就是说，如果你对它做add或者remove，都会抛UnsupportedOperationException。  
2.如果修改数组的值，list中的对应值也会改变！  
**Arrays.asList() 返回的是Arrays内部静态类，而不是Java.util.ArrayList的类。这个java.util.Arrays.ArrayList有set(),get(),contains()方法，但是没有任何add() 方法，所以它是固定大小的**

如果希望避免这两个坑，请改用这个方式

    Collections.addAll(arraylist, array);


#### <a name="test4">HashMap遍历</a> ####

在Java中有多种遍历HashMAp的方法。让我们回顾一下最常见的方法和它们各自的优缺点。由于所有的Map都实现了Map接口，所以接下来方法适用于所有Map（如：HaspMap，TreeMap,LinkedMap,HashTable,etc）

**方法#1 使用For-Each迭代entries**

这是最常见的方法，并在大多数情况下更可取的。当你在循环中需要使用Map的键和值时，就可以使用这个方法

    Map<Integer, Integer> map = new HashMap<Integer, Integer>();
    for(Map.Entry<Integer, Integer> entry : map.entrySet()){
    	System.out.println("key = " + entry.getKey() + ", value = " + entry.getValue())
    }
注意：For-Each循环是Java5新引入的，所以只能在Java5以上的版本中使用。如果你遍历的map是null的话，For-Each循环会抛出NullPointerException异常，所以在遍历之前你应该判断是否为空引用。

**方法#2 使用For-Each迭代keys和values**

如果你只需要用到map的keys或values时，你可以遍历KeySet或者values代替entrySet

    Map<Integer, Integer> map = new HashMap<Integer, Integer>();

    //iterating over keys only
    for (Integer key : map.keySet()) {
    	System.out.println("Key = " + key);
    }

    //iterating over values only
    for (Integer value : map.values()) {
    	System.out.println("Value = " + value);
    }
这个方法比entrySet迭代具有轻微的性能优势(大约快10%)并且代码更简洁

**方法#3 使用Iterator迭代**

    使用泛型

    Map<Integer, Integer> map = new HashMap<Integer, Integer>();
    Iterator<Map.Entry<Integer, Integer>> entries = map.entrySet().iterator();
    while (entries.hasNext()) {
    	Map.Entry<Integer, Integer> entry = entries.next();
    	System.out.println("Key = " + entry.getKey() + ", Value = " + entry.getValue());
    }
    不使用泛型

    Map map = new HashMap();
    Iterator entries = map.entrySet().iterator();
    while (entries.hasNext()) {
    	Map.Entry entry = (Map.Entry) entries.next();
    	Integer key = (Integer)entry.getKey();
    	Integer value = (Integer)entry.getValue();
    	System.out.println("Key = " + key + ", Value = " + value);
    }
你可以使用同样的技术迭代keyset或者values

这个似乎有点多余但它具有自己的优势。首先，它是遍历老java版本map的唯一方法。另外一个重要的特性是可以让你在迭代的时候从map中删除entries的(通过调用iterator.remover())唯一方法.如果你试图在For-Each迭代的时候删除entries，你将会得到unpredictable resultes 异常。

从性能方法看，这个方法等价于使用For-Each迭代

**方法#4 迭代keys并搜索values（低效的）**

    Map<Integer, Integer> map = new HashMap<Integer, Integer>();
    for (Integer key : map.keySet()) {
    	Integer value = map.get(key);
    	System.out.println("Key = " + key + ", Value = " + value);
    }
这个方法看上去比方法#1更简洁，但是实际上它更慢更低效，通过key得到value值更耗时（这个方法在所有实现map接口的map中比方法#1慢20%-200%）。如果你安装了FindBugs，它将检测并警告你这是一个低效的迭代。这个方法应该避免

总结

如果你只需要使用key或者value使用方法#2，如果你坚持使用java的老版本（java 5 以前的版本）或者打算在迭代的时候移除entries，使用方法#3。其他情况请使用#1方法。避免使用#4方法。

#### Java修饰符：public，protected，private，不加修饰符。有什么区别呢？####

如下表所示,Y表示能访问(可见性），N表示不能访问，例如第一行的第3个Y，表示类的变量/方法如果是用public修饰，它的子类能访问这个变量/方法

修饰符	类内部	同个包（package）	子类	其他范围

| 修饰符     |     类内部 |   同个包（package）	|  子类	   |   其他范围 |
| :-------- | --------: | :------:          | :------: | :------:  |
| public    |   Y       |  Y                | Y        |     Y     |
| protected |   Y       |  Y                |Y         |     N     |
| 无修饰符   |   Y       |  Y                |  N or Y(见说明）      |      N     |
| private   |   Y       |  N                |     N    |     N    |



说明： 需要特别说明“无修饰符”这个情况，子类能否访问父类中无修饰符的变量/方法，取决于子类的位置。如果子类和父类在同一个包中，那么子类可以访问父类中的无修饰符的变量/方法，否则不行。

译注：本来觉得很简单一个问题，没想记录的，但看到答案，才发现自己以前错了。我以前一直以为无修饰符和private是一样的，如果没给变量加修饰符，java就默认为private。

#### 如何测试一个数组是否包含指定的值####

指定数组，如:

public static final String[] VALUES = new String[] {"AB","BC","CD","AE"};
现在制定一个值 s，有哪些比较好的方式，判断这个数组 VALUES 是否包含值 s？

**简单且优雅的方法:**

```
Arrays.asList(...).contains(...)

使用 Apache Commons Lang包中的ArrayUtils.contains

String[] fieldsToInclude = { "id", "name", "location" };

if ( ArrayUtils.contains( fieldsToInclude, "id" ) ) {
    // Do some stuff.
}
```

**自己写逻辑**

问题的本质，其实是一个查找的问题，即查找一个数组是否包含某个值。对于原始类型，若是无序的数组，可以直接写一个 for 循环:

```
public static boolean useLoop(String[] arr, String targetValue) {
    for(String s: arr){
        if(s.equals(targetValue))
            return true;
    }
    return false;
}
```

若是有序的数组，可以考虑二分查找或者其他查找算法:

```
public static boolean useArraysBinarySearch(String[] arr, String targetValue) {
    int a =  Arrays.binarySearch(arr, targetValue);
    if(a >= 0)
        return true;
    else
        return false;
}
```

若数组里包含的是一个个对象，实际上比较就是引用是否相等(String 类型是判断 值是否相等)，本质就是比较 hashcode 和 equal 方法，可以考虑使用 List 或者 Set，如下

```
public static boolean useList(String[] arr, String targetValue) {
    return Arrays.asList(arr).contains(targetValue);
}
public static boolean useLoop(String[] arr, String targetValue) {
    for(String s: arr){
        if(s.equals(targetValue))
            return true;
    }
    return false;
}
```

#### 重写（Override）equals和hashCode方法时应考虑的问题####
 理论上讲（编程语言、数学层面） equals() 定义了对象的相等关系（自反性、对称性、传递性）（有点抽象，更详细说明，请参考javadoc) 。 另外，它还具有一致性（也就是说，如果一个对象没有修改，那么对象的equals方法，应总是返回相同的值），此外，o.equals(null)应当总是返回false。 hashCode()（javadoc)也必须具备一致性的（也就是说，如果equal的结果没有变，那么hashcode()也应总是返回相同的值）

总的来说，这两个方法的关系：

**假如a.equals(b)，那么a.hashCode() 应等于b.hashCode()**

实践上讲

**如果你重写了其中一个方法，那么务必重写另外一个方法**

equals()和hashCode()所计算的属性集（set of fields）应当是一样的 如何更快地重写这两个方法呢？

使用Apache Commons Lang library中的EqualsBuilder、HashCodeBuilder

```
public class Person {
    private String name;
    private int age;
    // ...

    public int hashCode() {
        return new HashCodeBuilder(17, 31). // two randomly chosen prime numbers
            // if deriving: appendSuper(super.hashCode()).
            append(name).
            append(age).
            toHashCode();
    }

    public boolean equals(Object obj) {
       if (!(obj instanceof Person))
            return false;
        if (obj == this)
            return true;

        Person rhs = (Person) obj;
        return new EqualsBuilder().
            // if deriving: appendSuper(super.equals(obj)).
            append(name, rhs.name).
            append(age, rhs.age).
            isEquals();
    }
}
```

如果你是用eclipse，可以在代码编辑区右键，然后选择 Source > Generate hashCode() and equals()
另外请记得

当你使用一些基于Hash的 Collection 、 Map，例如HashSet, LinkedHashSet, HashMap, Hashtable, 、WeakHashMap等。在键值对被放到集合中之后，请确保其key值所对应的hashCode()是保持不变的。比较可靠的一个办法，是保持这些key是不可变的，这也能带来不少好处
